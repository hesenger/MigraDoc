Index: MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Cell.cs
===================================================================
--- MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Cell.cs	(revision 5)
+++ MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Cell.cs	(revision 7)
@@ -310,6 +310,12 @@
     [DV]
     internal Borders borders;
 
+	  public bool HasBorders {
+		  get {
+			  return borders != null;
+		  }
+	  }
+
     /// <summary>
     /// Gets the shading object.
     /// </summary>
Index: MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Column.cs
===================================================================
--- MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Column.cs	(revision 5)
+++ MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Column.cs	(revision 7)
@@ -115,10 +115,10 @@
     {
       get
       {
-        if (IsNull("Index"))
+        if (index.IsNull) // AndrewT: optimization if (IsNull("Index"))
         {
           Columns clms = this.Parent as Columns;
-          SetValue("Index", clms.IndexOf(this));
+					clms.PopulateItemIndexes(); // AndrewT:optimization SetValue("Index", clms.IndexOf(this));
         }
         return index;
       }
Index: MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Columns.cs
===================================================================
--- MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Columns.cs	(revision 5)
+++ MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Columns.cs	(revision 7)
@@ -180,6 +180,15 @@
       }
     }
     static Meta meta;
+
+    /// <summary>
+    /// Set row.Index for each row in collection
+    /// </summary>
+    internal void PopulateItemIndexes() {
+      for (int index = 0; index < this.Count; index++)
+	      this[index].index = index;
+    }
+
     #endregion
   }
 }
Index: MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Row.cs
===================================================================
--- MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Row.cs	(revision 5)
+++ MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Row.cs	(revision 7)
@@ -121,10 +121,10 @@
     {
       get
       {
-        if (IsNull("index"))
+        if (index.IsNull) //AndrewT: optimization if (IsNull("index"))
         {
           Rows rws = this.parent as Rows;
-          SetValue("Index", rws.IndexOf(this));
+          rws.PopulateItemIndexes(); //AndrewT: optimization SetValue("Index", rws.IndexOf(this));
         }
         return index;
       }
Index: MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Rows.cs
===================================================================
--- MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Rows.cs	(revision 5)
+++ MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Tables/Rows.cs	(revision 7)
@@ -227,6 +227,15 @@
       }
     }
     static Meta meta;
-    #endregion
-  }
+
+    /// <summary>
+    /// Set row.Index for each row in collection
+    /// </summary>
+    internal void PopulateItemIndexes() {
+      for (int index = 0; index < this.Count; index++)
+	      this[index].index = index;
+    }
+
+		#endregion
+	}
 }
Index: MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Visitors/MergedCellList.cs
===================================================================
--- MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Visitors/MergedCellList.cs	(revision 5)
+++ MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel.Visitors/MergedCellList.cs	(revision 7)
@@ -28,10 +28,14 @@
 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 // DEALINGS IN THE SOFTWARE.
+
+// Andrew Tsekhansky (mailto:pakeha07@gmail.com): Table rendering optimization in 2010
 #endregion
 
 using System;
 using System.Collections;
+using System.Collections.Generic;
+
 using MigraDoc.DocumentObjectModel.IO;
 using MigraDoc.DocumentObjectModel.Tables;
 using MigraDoc.DocumentObjectModel.Visitors;
@@ -42,50 +46,10 @@
   /// <summary>
   /// Represents a merged list of cells of a table.
   /// </summary>
-  public class MergedCellList : ArrayList
+  public class MergedCellList 
   {
 
     /// <summary>
-    /// Enumerator that can iterate through the MergedCellList.
-    /// </summary>
-    public class Enumerator : IEnumerator
-    {
-      internal Enumerator(MergedCellList list)
-      {
-        this.list = list;
-      }
-
-      #region IEnumerator Members
-
-      public void Reset()
-      {
-        this.index = -1;
-      }
-
-      public Cell Current
-      {
-        get
-        {
-          return (Cell)this.list[this.index];
-        }
-      }
-
-      object IEnumerator.Current
-      {
-        get { return Current; }
-      }
-
-      public bool MoveNext()
-      {
-        return ++index < this.list.Count;
-      }
-      #endregion
-
-      MergedCellList list;
-      int index = -1;
-    }
-
-    /// <summary>
     /// Enumeration of neighbor positions of cells in a table.
     /// </summary>
     private enum NeighborPosition
@@ -104,66 +68,72 @@
       Init(table);
     }
 
+    private int RowCount;
+    private int ColCount;
+    private Table Table;
+    private CellInfo[,] CellInfos;
+    private Hashtable CellIndex;
+
     /// <summary>
     /// Initializes this instance from a table.
     /// </summary>
     private void Init(Table table)
     {
-      for (int rwIdx = 0; rwIdx < table.Rows.Count; ++rwIdx)
+      Table = table;
+      RowCount = Table.Rows.Count;
+      ColCount = Table.Columns.Count;
+
+      CellIndex = new Hashtable();
+      CellInfos = new CellInfo[RowCount, ColCount];
+      for (int rwIdx = 0; rwIdx < RowCount; rwIdx++)
       {
-        for (int clmIdx = 0; clmIdx < table.Columns.Count; ++clmIdx)
+        for (int clmIdx = 0; clmIdx < ColCount; clmIdx++)
         {
           Cell cell = table[rwIdx, clmIdx];
-          if (!IsAlreadyCovered(cell))
-            this.Add(cell);
+          if (CellInfos[rwIdx, clmIdx] == null) {
+            for (int mx = 0; mx <= cell.MergeRight; mx++)
+              for (int my = 0; my <= cell.MergeDown; my++) {
+                bool isMergedCell = mx > 0 || my > 0;
+                CellInfo cellInfo = new CellInfo(); 
+                cellInfo.TableCell = table[rwIdx + my, clmIdx + mx];
+                cellInfo.Cell = cell;
+                cellInfo.IsMergedCell = isMergedCell;
+                cellInfo.MergedWith = isMergedCell ? CellInfos[rwIdx, clmIdx] : null;
+                cellInfo.Row = rwIdx;
+                cellInfo.Col = clmIdx;
+
+                CellInfos[rwIdx + my, clmIdx + mx] = cellInfo;
+                CellIndex[cellInfo.TableCell] = CellInfos[rwIdx, clmIdx];
+              }
+          }
         }
       }
     }
 
-    /// <summary>
-    /// Returns whether the given cell is already covered by a preceding cell in this instance.
-    /// </summary>
-    /// <remarks>
-    /// Help function for Init().
-    /// </remarks>
-    private bool IsAlreadyCovered(Cell cell)
-    {
-      for (int index = this.Count - 1; index >= 0; --index)
-      {
+    public IEnumerable<Cell> GetCells() {
+      return GetCells(0, this.RowCount - 1);
+    }
 
-        Cell currentCell = this[index];
-        if (currentCell.Column.Index <= cell.Column.Index && currentCell.Column.Index + currentCell.MergeRight >= cell.Column.Index)
-        {
-          if (currentCell.Row.Index <= cell.Row.Index && currentCell.Row.Index + currentCell.MergeDown >= cell.Row.Index)
-            return true;
-          else if (currentCell.Row.Index + currentCell.MergeDown == cell.Row.Index - 1)
-            return false;
+    public IEnumerable<Cell> GetRowCells(int row) {
+      return GetCells(row, row);
+    }
 
+    public IEnumerable<Cell> GetCells(int startRow, int endRow) {
+      for (int rowIndex = startRow; rowIndex <= endRow; rowIndex++)
+        for (int colIndex = 0; colIndex < ColCount; colIndex++) {
+          CellInfo cellInfo = CellInfos[rowIndex, colIndex];
+          if (!cellInfo.IsMergedCell)
+            yield return cellInfo.Cell;
+          colIndex += cellInfo.Cell.MergeRight;
         }
-      }
-      return false;
+          
     }
 
-    /// <summary>
-    /// Gets the Enumerator for this list.
-    /// </summary>
-    public override IEnumerator GetEnumerator()
-    {
-      return new Enumerator(this);
+    private static Borders GetCellBorders(Cell cell) {
+      return cell.HasBorders ? cell.Borders : null; //AndrewT: optimization return cell.GetValue("Borders", GV.ReadOnly) as Borders;
     }
 
     /// <summary>
-    /// Gets the cell at the specified position.
-    /// </summary>
-    public new Cell this[int index]
-    {
-      get
-      {
-        return base[index] as Cell;
-      }
-    }
-
-    /// <summary>
     /// Gets a borders object that should be used for rendering.
     /// </summary>
     /// <exception cref="System.ArgumentException">
@@ -172,68 +142,65 @@
     /// </exception>
     public Borders GetEffectiveBorders(Cell cell)
     {
-      Borders borders = cell.GetValue("Borders", GV.ReadOnly) as Borders;
-      if (borders != null)
-      {
-        Document doc = borders.Document;
-        borders = borders.Clone();
-        borders.parent = cell;
-        doc = borders.Document;
-      }
-      else
-        borders = new Borders(cell.parent);
-
-      int cellIdx = this.BinarySearch(cell, new CellComparer());
-      if (!(cellIdx >= 0 && cellIdx < this.Count))
+      CellInfo cellInfo = this.CellIndex[cell] as CellInfo;
+      if (cellInfo == null)
         throw new ArgumentException("cell is not a relevant cell", "cell");
 
-      if (cell.mergeRight > 0)
-      {
-        Cell rightBorderCell = cell.Table[cell.Row.Index, cell.Column.Index + cell.mergeRight];
-        if (rightBorderCell.borders != null && rightBorderCell.borders.right != null)
-          borders.Right = rightBorderCell.borders.right.Clone();
+      if (cellInfo.Borders == null) {
+        Borders borders = GetCellBorders(cell);
+        if (borders != null) {
+          Document doc = borders.Document;
+          borders = borders.Clone();
+          borders.parent = cell;
+          doc = borders.Document;
+        }
         else
-          borders.right = null;
-      }
+          borders = new Borders(cell.parent);
 
-      if (cell.mergeDown > 0)
-      {
-        Cell bottomBorderCell = cell.Table[cell.Row.Index + cell.mergeDown, cell.Column.Index];
-        if (bottomBorderCell.borders != null && bottomBorderCell.borders.bottom != null)
-          borders.Bottom = bottomBorderCell.borders.bottom.Clone();
-        else
-          borders.bottom = null;
-      }
+        if (cell.mergeRight > 0) {
+          Cell rightBorderCell = cell.Table[cell.Row.Index, cell.Column.Index + cell.mergeRight];
+          if (rightBorderCell.borders != null && rightBorderCell.borders.right != null)
+            borders.Right = rightBorderCell.borders.right.Clone();
+          else
+            borders.right = null;
+        }
 
-      Cell leftNeighbor = GetNeighbor(cellIdx, NeighborPosition.Left);
-      Cell rightNeighbor = GetNeighbor(cellIdx, NeighborPosition.Right);
-      Cell topNeighbor = GetNeighbor(cellIdx, NeighborPosition.Top);
-      Cell bottomNeighbor = GetNeighbor(cellIdx, NeighborPosition.Bottom);
-      if (leftNeighbor != null)
-      {
-        Borders nbrBrdrs = leftNeighbor.GetValue("Borders", GV.ReadWrite) as Borders;
-        if (nbrBrdrs != null && GetEffectiveBorderWidth(nbrBrdrs, BorderType.Right) >= GetEffectiveBorderWidth(borders, BorderType.Left))
-          borders.SetValue("Left", GetBorderFromBorders(nbrBrdrs, BorderType.Right));
+        if (cell.mergeDown > 0) {
+          Cell bottomBorderCell = cell.Table[cell.Row.Index + cell.mergeDown, cell.Column.Index];
+          if (bottomBorderCell.borders != null && bottomBorderCell.borders.bottom != null)
+            borders.Bottom = bottomBorderCell.borders.bottom.Clone();
+          else
+            borders.bottom = null;
+        }
+
+        Cell leftNeighbor = GetNeighbor(cellInfo, NeighborPosition.Left);
+        Cell rightNeighbor = GetNeighbor(cellInfo, NeighborPosition.Right);
+        Cell topNeighbor = GetNeighbor(cellInfo, NeighborPosition.Top);
+        Cell bottomNeighbor = GetNeighbor(cellInfo, NeighborPosition.Bottom);
+        if (leftNeighbor != null) {
+          Borders nbrBrdrs = GetCellBorders(leftNeighbor);
+          if (nbrBrdrs != null && GetEffectiveBorderWidth(nbrBrdrs, BorderType.Right) >= GetEffectiveBorderWidth(borders, BorderType.Left))
+            borders.SetValue("Left", GetBorderFromBorders(nbrBrdrs, BorderType.Right));
+        }
+        if (rightNeighbor != null) {
+          Borders nbrBrdrs = GetCellBorders(rightNeighbor);
+          if (nbrBrdrs != null && GetEffectiveBorderWidth(nbrBrdrs, BorderType.Left) > GetEffectiveBorderWidth(borders, BorderType.Right))
+            borders.SetValue("Right", GetBorderFromBorders(nbrBrdrs, BorderType.Left));
+        }
+        if (topNeighbor != null) {
+          Borders nbrBrdrs = GetCellBorders(topNeighbor);
+          if (nbrBrdrs != null && GetEffectiveBorderWidth(nbrBrdrs, BorderType.Bottom) >= GetEffectiveBorderWidth(borders, BorderType.Top))
+            borders.SetValue("Top", GetBorderFromBorders(nbrBrdrs, BorderType.Bottom));
+        }
+        if (bottomNeighbor != null) {
+          Borders nbrBrdrs = GetCellBorders(bottomNeighbor);
+          if (nbrBrdrs != null && GetEffectiveBorderWidth(nbrBrdrs, BorderType.Top) > GetEffectiveBorderWidth(borders, BorderType.Bottom))
+            borders.SetValue("Bottom", GetBorderFromBorders(nbrBrdrs, BorderType.Top));
+        }
+
+        cellInfo.Borders = borders;
       }
-      if (rightNeighbor != null)
-      {
-        Borders nbrBrdrs = rightNeighbor.GetValue("Borders", GV.ReadWrite) as Borders;
-        if (nbrBrdrs != null && GetEffectiveBorderWidth(nbrBrdrs, BorderType.Left) > GetEffectiveBorderWidth(borders, BorderType.Right))
-          borders.SetValue("Right", GetBorderFromBorders(nbrBrdrs, BorderType.Left));
-      }
-      if (topNeighbor != null)
-      {
-        Borders nbrBrdrs = topNeighbor.GetValue("Borders", GV.ReadWrite) as Borders;
-        if (nbrBrdrs != null && GetEffectiveBorderWidth(nbrBrdrs, BorderType.Bottom) >= GetEffectiveBorderWidth(borders, BorderType.Top))
-          borders.SetValue("Top", GetBorderFromBorders(nbrBrdrs, BorderType.Bottom));
-      }
-      if (bottomNeighbor != null)
-      {
-        Borders nbrBrdrs = bottomNeighbor.GetValue("Borders", GV.ReadWrite) as Borders;
-        if (nbrBrdrs != null && GetEffectiveBorderWidth(nbrBrdrs, BorderType.Top) > GetEffectiveBorderWidth(borders, BorderType.Bottom))
-          borders.SetValue("Bottom", GetBorderFromBorders(nbrBrdrs, BorderType.Top));
-      }
-      return borders;
+      return cellInfo.Borders;
     }
 
     /// <summary>
@@ -241,21 +208,7 @@
     /// </summary>
     public Cell GetCoveringCell(Cell cell)
     {
-      int cellIdx = this.BinarySearch(cell, new CellComparer());
-      if (cellIdx >= 0 && cellIdx < this.Count)
-        return this[cellIdx];
-      else //Binary Search returns the complement of the next value, therefore, "~cellIdx - 1" is the previous cell.
-        cellIdx = ~cellIdx - 1;
-      for (int index = cellIdx; index >= 0; --index)
-      {
-        Cell currCell = this[index];
-        if (currCell.Column.Index <= cell.Column.Index &&
-          currCell.Column.Index + currCell.MergeRight >= cell.Column.Index &&
-          currCell.Row.Index <= cell.Row.Index &&
-          currCell.Row.Index + currCell.MergeDown >= cell.Row.Index)
-          return currCell;
-      }
-      return null;
+      return ((CellInfo)CellIndex[cell]).Cell;
     }
 
     /// <summary>
@@ -284,117 +237,153 @@
       if (borders == null)
         return 0;
 
-      Border border = borders.GetValue(type.ToString(), GV.GetNull) as Border;
-
-      DocumentObject relevantDocObj = border;
-      if (relevantDocObj == null || relevantDocObj.IsNull("Width"))
-        relevantDocObj = borders;
-
-      object visible = relevantDocObj.GetValue("visible", GV.GetNull);
-      object style = relevantDocObj.GetValue("style", GV.GetNull);
-      object width = relevantDocObj.GetValue("width", GV.GetNull);
-      object color = relevantDocObj.GetValue("color", GV.GetNull);
-
-      if (visible != null || style != null || width != null || color != null)
-      {
-        if (visible != null && !(bool)visible)
-          return 0;
-        if (width != null)
-          return (Unit)width;
-
-        return 0.5;
-      }
-      return 0;
+      return borders.GetEffectiveWidth(type);
     }
 
     /// <summary>
     /// Gets the specified cell's uppermost neighbor at the specified position.
     /// </summary>
-    private Cell GetNeighbor(int cellIdx, NeighborPosition position)
+    private Cell GetNeighbor(CellInfo cellInfo, NeighborPosition position)
     {
-      Cell cell = this[cellIdx];
-      if (cell.Column.Index == 0 && position == NeighborPosition.Left ||
-        cell.Row.Index == 0 && position == NeighborPosition.Top ||
-        cell.Row.Index + cell.MergeDown == cell.Table.Rows.Count - 1 && position == NeighborPosition.Bottom ||
-        cell.Column.Index + cell.MergeRight == cell.Table.Columns.Count - 1 && position == NeighborPosition.Right)
-        return null;
+      Cell cell = cellInfo.Cell;
 
-      switch (position)
-      {
-        case NeighborPosition.Top:
-        case NeighborPosition.Left:
-          for (int index = cellIdx - 1; index >= 0; --index)
-          {
-            Cell currCell = this[index];
-            if (IsNeighbor(cell, currCell, position))
-              return currCell;
-          }
-          break;
+      switch (position) {
+		case NeighborPosition.Left:
+			if (cellInfo.BlockCol > 0)
+				return CellInfos[cellInfo.BlockRow, cellInfo.BlockCol - 1].Cell;
+			break;
 
-        case NeighborPosition.Right:
-          if (cellIdx + 1 < this.Count)
-          {
-            Cell cell2 = this[cellIdx + 1];
-            if (cell2.Row.Index == cell.Row.Index)
-              return cell2;
-          }
-          for (int index = cellIdx - 1; index >= 0; --index)
-          {
-            Cell currCell = this[index];
-            if (IsNeighbor(cell, currCell, position))
-              return currCell;
-          }
-          break;
+		case NeighborPosition.Right:
+			if (cellInfo.BlockCol + cell.MergeRight < ColCount - 1)
+				return CellInfos[cellInfo.BlockRow, cellInfo.BlockCol + cell.MergeRight + 1].Cell;
+			break;
 
-        case NeighborPosition.Bottom:
-          for (int index = cellIdx + 1; index < this.Count; ++index)
-          {
-            Cell currCell = this[index];
-            if (IsNeighbor(cell, currCell, position))
-              return currCell;
-          }
-          break;
-      }
+		case NeighborPosition.Top:
+			if (cellInfo.BlockRow > 0)
+				return CellInfos[cellInfo.BlockRow - 1, cellInfo.BlockCol].Cell;
+			break;
+
+		case NeighborPosition.Bottom:
+			if (cellInfo.BlockRow + cell.MergeDown < RowCount - 1)
+				return CellInfos[cellInfo.BlockRow + cell.MergeDown + 1, cellInfo.BlockCol].Cell;
+			break;
+	  }
+      //Cell cell = cellInfo.CoverCell;
+      //if (cell.Column.Index == 0 && position == NeighborPosition.Left ||
+      //  cell.Row.Index == 0 && position == NeighborPosition.Top ||
+      //  cell.Row.Index + cell.MergeDown == cell.Table.Rows.Count - 1 && position == NeighborPosition.Bottom ||
+      //  cell.Column.Index + cell.MergeRight == cell.Table.Columns.Count - 1 && position == NeighborPosition.Right)
+      //  return null;
+
+      //switch (position)
+      //{
+      //  case NeighborPosition.Top:
+      //  case NeighborPosition.Left:
+      //    for (int index = cellIdx - 1; index >= 0; --index)
+      //    {
+      //      Cell currCell = this[index];
+      //      if (IsNeighbor(cell, currCell, position))
+      //        return currCell;
+      //    }
+      //    break;
+
+      //  case NeighborPosition.Right:
+      //    if (cellIdx + 1 < this.Count)
+      //    {
+      //      Cell cell2 = this[cellIdx + 1];
+      //      if (cell2.Row.Index == cell.Row.Index)
+      //        return cell2;
+      //    }
+      //    for (int index = cellIdx - 1; index >= 0; --index)
+      //    {
+      //      Cell currCell = this[index];
+      //      if (IsNeighbor(cell, currCell, position))
+      //        return currCell;
+      //    }
+      //    break;
+
+      //  case NeighborPosition.Bottom:
+      //    for (int index = cellIdx + 1; index < this.Count; ++index)
+      //    {
+      //      Cell currCell = this[index];
+      //      if (IsNeighbor(cell, currCell, position))
+      //        return currCell;
+      //    }
+      //    break;
+      //}
       return null;
     }
 
-    /// <summary>
-    /// Returns whether cell2 is a neighbor of cell1 at the specified position.
-    /// </summary>
-    private bool IsNeighbor(Cell cell1, Cell cell2, NeighborPosition position)
-    {
-      bool isNeighbor = false;
-      switch (position)
-      {
-        case NeighborPosition.Bottom:
-          int bottomRowIdx = cell1.Row.Index + cell1.MergeDown + 1;
-          isNeighbor = cell2.Row.Index == bottomRowIdx &&
-            cell2.Column.Index <= cell1.Column.Index &&
-            cell2.Column.Index + cell2.MergeRight >= cell1.Column.Index;
-          break;
+    public int CalcLastConnectedRow(int row) {
+			int lastConnectedRow = row;
+			for (int rowIndex = row; rowIndex <= lastConnectedRow && rowIndex < this.RowCount; rowIndex++)
+			{
+				int downConnection = rowIndex;
+				for (int colIndex = 0; colIndex < this.ColCount; colIndex++)
+				{
+					CellInfo cellInfo = CellInfos[rowIndex, colIndex];
+					downConnection = Math.Max(downConnection, cellInfo.BlockRow + Math.Max(cellInfo.Cell.Row.KeepWith, cellInfo.Cell.MergeDown));
+					colIndex += cellInfo.Cell.MergeRight;
+				}
+				lastConnectedRow = Math.Max(lastConnectedRow, downConnection);
+			}
 
-        case NeighborPosition.Left:
-          int leftClmIdx = cell1.Column.Index - 1;
-          isNeighbor = cell2.Row.Index <= cell1.Row.Index &&
-            cell2.Row.Index + cell2.MergeDown >= cell1.Row.Index &&
-            cell2.Column.Index + cell2.MergeRight == leftClmIdx;
-          break;
+			return Math.Min(this.RowCount - 1, lastConnectedRow);
+    }
 
-        case NeighborPosition.Right:
-          int rightClmIdx = cell1.Column.Index + cell1.MergeRight + 1;
-          isNeighbor = cell2.Row.Index <= cell1.Row.Index &&
-            cell2.Row.Index + cell2.MergeDown >= cell1.Row.Index &&
-            cell2.Column.Index == rightClmIdx;
-          break;
+    public int CalcLastConnectedColumn(int column) {
+			int lastConnectedColumn = column;
 
-        case NeighborPosition.Top:
-          int topRowIdx = cell1.Row.Index - 1;
-          isNeighbor = cell2.Row.Index + cell2.MergeDown == topRowIdx &&
-            cell2.Column.Index + cell2.MergeRight >= cell1.Column.Index &&
-            cell2.Column.Index <= cell1.Column.Index;
-          break;
+			for (int colIndex = column; colIndex <= lastConnectedColumn && colIndex < this.ColCount; colIndex++)
+			{
+				int rightConnection = column;
+				for (int rowIndex = 0; rowIndex < this.RowCount; rowIndex++)
+				{
+					CellInfo cellInfo = CellInfos[rowIndex, colIndex];
+					cellInfo = cellInfo.MergedWith ?? cellInfo;
+					rightConnection = Math.Max(rightConnection, cellInfo.BlockCol + Math.Max(cellInfo.Cell.Column.KeepWith, cellInfo.Cell.MergeRight));
+					rowIndex += cellInfo.Cell.MergeDown;
+				}
+				lastConnectedColumn = Math.Max(lastConnectedColumn, rightConnection);
+			}
+      return Math.Min(lastConnectedColumn, this.ColCount);
+    }
+  }
+
+  internal class CellInfo {
+
+    // Cell from table at given Row, Col
+    public Cell TableCell;
+
+    // Cell which fills given Row, Col
+    public Cell Cell;
+
+    // Whether cell is merged with another cell
+    public bool IsMergedCell;
+
+    // CellInfo this cell is merged with
+    public CellInfo MergedWith;
+
+    // Cell's Row 
+    public int Row;
+
+    // Cells' Col
+    public int Col;
+
+    // Row where merged area starts
+    public int BlockRow {
+      get {
+        return MergedWith == null ? Row : MergedWith.Row;
       }
-      return isNeighbor;
     }
+
+    // Col where merged area starts
+    public int BlockCol {
+      get {
+        return MergedWith == null ? Col : MergedWith.Col;
+      }
+    }
+
+    public Borders Borders;
   }
 }
Index: MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel/Borders.cs
===================================================================
--- MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel/Borders.cs	(revision 5)
+++ MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel/Borders.cs	(revision 7)
@@ -65,7 +65,7 @@
       if (!Enum.IsDefined(typeof(BorderType), type))
         throw new InvalidEnumArgumentException("type");
 
-      return !(this.IsNull(type.ToString()));
+      return this.GetBorder(type) != null; // AndrewT: optimization return !(this.IsNull(type.ToString()));
     }
 
     #region Methods
@@ -140,6 +140,83 @@
     {
       this.clearAll = true;
     }
+
+    /// <summary>
+    /// Return border if specified, fast version of Borders.GetValue(type.ToString(), RV.ReadOnly)
+    /// </summary>
+    /// <param name="type"></param>
+    /// <returns></returns>
+    public Border GetBorder(BorderType type) {
+      // AndrewT: optimization - time-critical routine due to high calls number when render tables
+      switch (type) {
+        case BorderType.Left:
+          return this.left;
+
+        case BorderType.Right:
+          return this.right;
+
+        case BorderType.Top:
+          return this.top;
+
+        case BorderType.Bottom:
+          return this.bottom;
+
+        case BorderType.DiagonalDown:
+          return this.diagonalDown;
+
+        case BorderType.DiagonalUp:
+          return this.diagonalUp;
+
+        default:
+          return this.GetValue(type.ToString(), GV.ReadOnly) as Border;
+      }
+    }
+
+    public BorderStyle GetEffectiveBorderStyle(BorderType type) {
+      Border border = GetBorder(type);
+      if (border != null && !border.style.IsNull)
+        return border.Style;
+      else if (!this.style.IsNull)
+        return this.Style;
+
+      return BorderStyle.Single;
+    }
+
+
+    /// <summary>
+    /// Returns effective width in points
+    /// </summary>
+    /// <param name="type"></param>
+    /// <returns></returns>
+    public double GetEffectiveWidth(BorderType type) {
+      Border border = this.GetBorder(type);
+
+      if (border != null) {
+        if (!border.visible.IsNull && !border.Visible)
+          return 0;
+
+        if (border != null && !border.width.IsNull)
+          return border.Width.Point;
+
+        if (!border.color.IsNull || !border.style.IsNull || border.Visible) {
+          if (!this.width.IsNull)
+            return this.Width.Point;
+
+          return 0.5;
+        }
+      }
+      else if (!(type == BorderType.DiagonalDown || type == BorderType.DiagonalUp)) {
+        if (!this.visible.IsNull && !this.Visible)
+          return 0;
+
+        if (!this.width.IsNull)
+          return this.Width.Point;
+
+        if (!this.color.IsNull || !this.style.IsNull || this.Visible)
+          return 0.5;
+      }
+      return 0;
+    }
     #endregion
 
     #region Properties
@@ -313,6 +390,12 @@
     [DV]
     internal Color color = Color.Empty;
 
+    public bool HasColor {
+      get {
+        return !this.color.IsNull;
+      }
+    }
+
     /// <summary>
     /// Gets or sets the distance between text and the top border.
     /// </summary>
Index: MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel/Styles.cs
===================================================================
--- MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel/Styles.cs	(revision 5)
+++ MigraDoc/code/MigraDoc.DocumentObjectModel/MigraDoc.DocumentObjectModel/Styles.cs	(revision 7)
@@ -70,6 +70,8 @@
       return (Styles)base.DeepCopy();
     }
 
+    private Hashtable NameIndex = new Hashtable(StringComparer.CurrentCultureIgnoreCase);
+
     /// <summary>
     /// Gets a style by its name.
     /// </summary>
@@ -77,15 +79,17 @@
     {
       get
       {
-        int count = Count;
-        // index starts from 1; DefaultParagraphFont cannot be modified.
-        for (int index = 1; index < count; ++index)
-        {
-          Style style = (Style)this[index];
-          if (String.Compare(style.Name, styleName, true) == 0)
-            return style;
-        }
-        return null;
+        Style res = NameIndex[styleName] as Style;
+        return res == this[0] ? null : res;
+        //int count = Count;
+        //// index starts from 1; DefaultParagraphFont cannot be modified.
+        //for (int index = 1; index < count; ++index)
+        //{
+        //  Style style = (Style)this[index];
+        //  if (String.Compare(style.Name, styleName, StringComparison.CurrentCultureIgnoreCase) == 0)
+        //    return style;
+        //}
+        //return null;
       }
     }
 
@@ -174,6 +178,8 @@
       }
       else
         base.Add(value);
+
+      NameIndex[style.Name] = style;
     }
     #endregion
 
Index: MigraDoc/code/MigraDoc.Rendering/MigraDoc.Rendering/BordersRenderer.cs
===================================================================
--- MigraDoc/code/MigraDoc.Rendering/MigraDoc.Rendering/BordersRenderer.cs	(revision 5)
+++ MigraDoc/code/MigraDoc.Rendering/MigraDoc.Rendering/BordersRenderer.cs	(revision 7)
@@ -49,16 +49,11 @@
       this.borders = borders;
     }
 
-    private Border GetBorder(BorderType type)
-    {
-      return (Border)this.borders.GetValue(type.ToString(), GV.ReadOnly);
-    }
-
     private XColor GetColor(BorderType type)
     {
       Color clr = Colors.Black;
 
-      Border border = GetBorder(type);
+      Border border = borders.GetBorder(type);
       if (border != null && !border.Color.IsEmpty)
         clr = border.Color;
       else if (!this.borders.Color.IsEmpty)
@@ -80,15 +75,16 @@
 
     private BorderStyle GetStyle(BorderType type)
     {
-      BorderStyle style = BorderStyle.Single;
+      return borders.GetEffectiveBorderStyle(type);
+      //BorderStyle style = BorderStyle.Single;
 
-      Border border = GetBorder(type);
-      if (border != null && !border.IsNull("Style"))
-        style = border.Style;
-      else if (!this.borders.IsNull("Style"))
-        style = this.borders.Style;
+      //Border border = borders.GetBorder(type);
+      //if (border != null && !border.IsNull("Style"))
+      //  style = border.Style;
+      //else if (!this.borders.IsNull("Style"))
+      //  style = this.borders.Style;
 
-      return style;
+      //return style;
     }
 
     internal XUnit GetWidth(BorderType type)
@@ -96,36 +92,7 @@
       if (this.borders == null)
         return 0;
 
-      Border border = GetBorder(type);
-
-      if (border != null)
-      {
-        if (!border.IsNull("Visible") && !border.Visible)
-          return 0;
-
-        if (border != null && !border.IsNull("Width"))
-          return border.Width.Point;
-
-        if (!border.IsNull("Color") || !border.IsNull("Style") || border.Visible)
-        {
-          if (!this.borders.IsNull("Width"))
-            return this.borders.Width.Point;
-
-          return 0.5;
-        }
-      }
-      else if (!(type == BorderType.DiagonalDown || type == BorderType.DiagonalUp))
-      {
-        if (!this.borders.IsNull("Visible") && !this.borders.Visible)
-          return 0;
-
-        if (!this.borders.IsNull("Width"))
-          return this.borders.Width.Point;
-
-        if (!this.borders.IsNull("Color") || !this.borders.IsNull("Style") || this.borders.Visible)
-          return 0.5;
-      }
-      return 0;
+      return borders.GetEffectiveWidth(type);
     }
 
     /// <summary>
Index: MigraDoc/code/MigraDoc.Rendering/MigraDoc.Rendering/TableFormatInfo.cs
===================================================================
--- MigraDoc/code/MigraDoc.Rendering/MigraDoc.Rendering/TableFormatInfo.cs	(revision 5)
+++ MigraDoc/code/MigraDoc.Rendering/MigraDoc.Rendering/TableFormatInfo.cs	(revision 7)
@@ -86,7 +86,7 @@
     internal int endRow = -1;
 
     internal int lastHeaderRow = -1;
-    internal SortedList formattedCells;
+    internal Hashtable formattedCells;
     internal MergedCellList mergedCells;
     internal SortedList bottomBorderMap;
     internal SortedList connectedRowsMap;
Index: MigraDoc/code/MigraDoc.Rendering/MigraDoc.Rendering/TableRenderer.cs
===================================================================
--- MigraDoc/code/MigraDoc.Rendering/MigraDoc.Rendering/TableRenderer.cs	(revision 5)
+++ MigraDoc/code/MigraDoc.Rendering/MigraDoc.Rendering/TableRenderer.cs	(revision 7)
@@ -26,6 +26,9 @@
 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 // DEALINGS IN THE SOFTWARE.
+//
+// Andrew Tsekhansky (mailto:pakeha07@gmail.com): Table rendering optimization in 2010
+
 #endregion
 
 using System;
@@ -98,11 +101,8 @@
       if (this.lastHeaderRow < 0)
         return;
 
-      foreach (Cell cell in this.mergedCells)
-      {
-        if (cell.Row.Index <= this.lastHeaderRow)
-          RenderCell(cell);
-      }
+      foreach (Cell cell in this.mergedCells.GetCells(0, this.lastHeaderRow))
+        RenderCell(cell); 
     }
 
     void RenderCell(Cell cell)
@@ -223,18 +223,21 @@
       RenderHeaderRows();
       if (startRow < this.table.Rows.Count)
       {
-        Cell cell = this.table[startRow, 0];
+        // AndrewT: optimization
+        //  Cell cell = this.table[startRow, 0];
 
-        int cellIdx = this.mergedCells.BinarySearch(this.table[startRow, 0], new CellComparer());
-        while (cellIdx < this.mergedCells.Count)
-        {
-          cell = (Cell)this.mergedCells[cellIdx];
-          if (cell.Row.Index > this.endRow)
-            break;
+        //  int cellIdx = this.mergedCells.BinarySearch(this.table[startRow, 0], new CellComparer());
+        //  while (cellIdx < this.mergedCells.Count)
+        //  {
+        //    cell = (Cell)this.mergedCells[cellIdx];
+        //    if (cell.Row.Index > this.endRow)
+        //      break;
 
+        //    RenderCell(cell);
+        //    ++cellIdx;
+        //  }
+        foreach (Cell cell in mergedCells.GetCells(startRow, endRow))
           RenderCell(cell);
-          ++cellIdx;
-        }
       }
     }
 
@@ -278,8 +281,8 @@
 
     void FormatCells()
     {
-      this.formattedCells = new SortedList(new CellComparer());
-      foreach (Cell cell in this.mergedCells)
+      this.formattedCells = new Hashtable(); // AndrewT: seems that order is not required here new SortedList(new CellComparer());
+      foreach (Cell cell in this.mergedCells.GetCells())
       {
         FormattedCell formattedCell = new FormattedCell(cell, this.documentRenderer, this.mergedCells.GetEffectiveBorders(cell), this.fieldInfos, 0, 0);
         formattedCell.Format(this.gfx);
@@ -492,7 +495,7 @@
     void CreateConnectedRows()
     {
       this.connectedRowsMap = new SortedList();
-      foreach (Cell cell in this.mergedCells)
+      foreach (Cell cell in this.mergedCells.GetCells())
       {
         if (!this.connectedRowsMap.ContainsKey(cell.Row.Index))
         {
@@ -505,7 +508,7 @@
     void CreateConnectedColumns()
     {
       this.connectedColumnsMap = new SortedList();
-      foreach (Cell cell in this.mergedCells)
+      foreach (Cell cell in this.mergedCells.GetCells())
       {
         if (!this.connectedColumnsMap.ContainsKey(cell.Column.Index))
         {
@@ -534,23 +537,33 @@
       XUnit maxWidth = 0;
       if (this.table.Rows.Count > row)
       {
-        int cellIdx = this.mergedCells.BinarySearch(this.table[row, 0], new CellComparer());
-        Cell rowCell = this.mergedCells[cellIdx];
-        while (cellIdx < this.mergedCells.Count)
-        {
-          rowCell = this.mergedCells[cellIdx];
-          if (rowCell.Row.Index > row)
-            break;
+        //AndrewT: optimization
+        //int cellIdx = this.mergedCells.BinarySearch(this.table[row, 0], new CellComparer());
+        //Cell rowCell = this.mergedCells[cellIdx];
+        //while (cellIdx < this.mergedCells.Count)
+        //{
+        //  rowCell = this.mergedCells[cellIdx];
+        //  if (rowCell.Row.Index > row)
+        //    break;
 
-          if (!rowCell.IsNull("Borders"))
-          {
+        //  if (!rowCell.IsNull("Borders"))
+        //  {
+        //    BordersRenderer bordersRenderer = new BordersRenderer(rowCell.Borders, this.gfx);
+        //    XUnit width = 0;
+        //    width = bordersRenderer.GetWidth(BorderType.Top);
+        //    if (width > maxWidth)
+        //      maxWidth = width;
+        //  }
+        //  ++cellIdx;
+        //}
+        foreach (Cell rowCell in this.mergedCells.GetRowCells(row)) {
+          if (rowCell.HasBorders) {
             BordersRenderer bordersRenderer = new BordersRenderer(rowCell.Borders, this.gfx);
             XUnit width = 0;
             width = bordersRenderer.GetWidth(BorderType.Top);
             if (width > maxWidth)
               maxWidth = width;
           }
-          ++cellIdx;
         }
       }
       return maxWidth;
@@ -569,13 +582,24 @@
       XUnit maxBottomBorderPosition = lastPos + minMergedFormattedCell.InnerHeight;
       maxBottomBorderPosition += CalcBottomBorderWidth(minMergedCell);
 
-      foreach (Cell cell in this.mergedCells)
-      {
-        if (cell.Row.Index > minMergedCell.Row.Index + minMergedCell.MergeDown)
-          break;
+      // AndrewT: optimization
+      //foreach (Cell cell in this.mergedCells)
+      //{
+      //  if (cell.Row.Index > minMergedCell.Row.Index + minMergedCell.MergeDown)
+      //    break;
 
-        if (cell.Row.Index + cell.MergeDown == minMergedCell.Row.Index + minMergedCell.MergeDown)
-        {
+      //  if (cell.Row.Index + cell.MergeDown == minMergedCell.Row.Index + minMergedCell.MergeDown)
+      //  {
+      //    FormattedCell formattedCell = (FormattedCell)this.formattedCells[cell];
+      //    XUnit topBorderPos = (XUnit)this.bottomBorderMap[cell.Row.Index];
+      //    XUnit bottomBorderPos = topBorderPos + formattedCell.InnerHeight;
+      //    bottomBorderPos += CalcBottomBorderWidth(cell);
+      //    if (bottomBorderPos > maxBottomBorderPosition)
+      //      maxBottomBorderPosition = bottomBorderPos;
+      //  }
+      //}
+      foreach (Cell cell in this.mergedCells.GetCells(lastBorderRow, minMergedCell.Row.Index + minMergedCell.MergeDown))
+        if (cell.Row.Index + cell.MergeDown == minMergedCell.Row.Index + minMergedCell.MergeDown) {
           FormattedCell formattedCell = (FormattedCell)this.formattedCells[cell];
           XUnit topBorderPos = (XUnit)this.bottomBorderMap[cell.Row.Index];
           XUnit bottomBorderPos = topBorderPos + formattedCell.InnerHeight;
@@ -583,7 +607,7 @@
           if (bottomBorderPos > maxBottomBorderPosition)
             maxBottomBorderPosition = bottomBorderPos;
         }
-      }
+
       this.bottomBorderMap.Add(minMergedCell.Row.Index + minMergedCell.MergeDown + 1, maxBottomBorderPosition);
     }
 
@@ -612,24 +636,17 @@
     {
       int minMerge = this.table.Rows.Count;
       Cell minCell = null;
-      foreach (Cell cell in this.mergedCells)
-      {
-        if (cell.Row.Index == row)
-        {
-          if (cell.MergeDown == 0)
-          {
-            minCell = cell;
-            break;
-          }
-          else if (cell.MergeDown < minMerge)
-          {
-            minMerge = cell.MergeDown;
-            minCell = cell;
-          }
+      foreach (Cell cell in this.mergedCells.GetRowCells(row)) {
+        if (cell.MergeDown == 0) {
+          minCell = cell;
+          break;
         }
-        else if (cell.Row.Index > row)
-          break;
+        else if (cell.MergeDown < minMerge) {
+          minMerge = cell.MergeDown;
+          minCell = cell;
+        }
       }
+
       return minCell;
     }
 
@@ -641,17 +658,20 @@
     /// <returns>The last row that is connected with the given row.</returns>
     int CalcLastConnectedRow(int row)
     {
-      int lastConnectedRow = row;
-      foreach (Cell cell in this.mergedCells)
-      {
-        if (cell.Row.Index <= lastConnectedRow)
-        {
-          int downConnection = Math.Max(cell.Row.KeepWith, cell.MergeDown);
-          if (lastConnectedRow < cell.Row.Index + downConnection)
-            lastConnectedRow = cell.Row.Index + downConnection;
-        }
-      }
-      return lastConnectedRow;
+      return this.mergedCells.CalcLastConnectedRow(row);
+      // AndrewT: moved to MergedCells
+      //int lastConnectedRow = row;
+      //foreach (Cell cell in this.mergedCells)
+      //{
+      //  if (cell.Row.Index <= lastConnectedRow)
+      //  {
+      //    int downConnection = Math.Max(cell.Row.KeepWith, cell.MergeDown);
+      //    if (lastConnectedRow < cell.Row.Index + downConnection)
+      //      lastConnectedRow = cell.Row.Index + downConnection;
+      //  }
+      //}
+
+      //return lastConnectedRow;
     }
 
     /// <summary>
@@ -661,24 +681,26 @@
     /// <returns>The last column that is connected with the given column.</returns>
     int CalcLastConnectedColumn(int column)
     {
-      int lastConnectedColumn = column;
-      foreach (Cell cell in this.mergedCells)
-      {
-        if (cell.Column.Index <= lastConnectedColumn)
-        {
-          int rightConnection = Math.Max(cell.Column.KeepWith, cell.MergeRight);
-          if (lastConnectedColumn < cell.Column.Index + rightConnection)
-            lastConnectedColumn = cell.Column.Index + rightConnection;
-        }
-      }
-      return lastConnectedColumn;
+      return this.mergedCells.CalcLastConnectedColumn(column);
+      // AndrewT: moved to MergedCells
+      //int lastConnectedColumn = column;
+      //foreach (Cell cell in this.mergedCells)
+      //{
+      //  if (cell.Column.Index <= lastConnectedColumn)
+      //  {
+      //    int rightConnection = Math.Max(cell.Column.KeepWith, cell.MergeRight);
+      //    if (lastConnectedColumn < cell.Column.Index + rightConnection)
+      //      lastConnectedColumn = cell.Column.Index + rightConnection;
+      //  }
+      //}
+      //return lastConnectedColumn;
     }
 
 
 
     Table table;
     MergedCellList mergedCells;
-    SortedList formattedCells;
+    Hashtable formattedCells;
     SortedList bottomBorderMap;
     SortedList connectedRowsMap;
     SortedList connectedColumnsMap;
